# .github/workflows/frontend-cd.yml
name: CD - Deploy Frontend to AKS

on:
  # auto-trigger after backend workflow finishes
name: CD - Deploy Frontend to AKS

on:
  workflow_run:
    types: [completed]            # listen to ANY workflow finishing
    branches: ["main"]            # only runs when the upstream run was on main
  workflow_dispatch:
    inputs: {}                    # keep manual run support

jobs:
  deploy_frontend:
    # only run when the upstream workflow SUCCEEDED
    # and the upstream workflow file is your backend workflow file
    if: >
      ${{
        github.event_name == 'workflow_dispatch' ||
        (
          github.event_name == 'workflow_run' &&
          github.event.workflow_run.conclusion == 'success' &&
          endsWith(github.event.workflow_run.path, '.github/workflows/backend-cd.yml')
        )
      }}
    runs-on: ubuntu-latest
    environment: Production
  # manual run still supported
  workflow_dispatch:
    inputs:
      product_api_ip:
        description: 'External Product API URL (e.g., http://X.X.X.X:8000)'
        required: false
        default: 'http://<ip_address>:8000'
      order_api_ip:
        description: 'External Order API URL (e.g., http://Y.Y.Y.Y:8001)'
        required: false
        default: 'http://<ip_address>:8001'
      aks_cluster_name:
        description: 'AKS cluster (manual runs only)'
        required: false
        default: '<aks_name>'
      aks_resource_group:
        description: 'AKS resource group (manual runs only)'
        required: false
        default: '<resource_group_name>'

  # (optional) callable from other workflows
  workflow_call:
    inputs:
      product_api_ip:      { required: true,  type: string }
      order_api_ip:        { required: true,  type: string }
      aks_cluster_name:    { required: true,  type: string }
      aks_resource_group:  { required: true,  type: string }

jobs:
  deploy_frontend:
    # run on successful backend run OR manual/call
    if: ${{ github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call' || (github.event.workflow_run.conclusion == 'success') }}
    runs-on: ubuntu-latest
    environment: Production

    env:
      # your real K8s Service names + ports
      PRODUCT_SVC: product-service-w08e1
      ORDER_SVC:   order-service-w08e1
      PRODUCT_PORT: "8000"
      ORDER_PORT:   "8001"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context
        uses: azure/aks-set-context@v3
        with:
          # use inputs for manual runs, secrets for auto-runs
          resource-group: ${{ github.event_name == 'workflow_dispatch' && inputs.aks_resource_group || secrets.AKS_RESOURCE_GROUP }}
          cluster-name:   ${{ github.event_name == 'workflow_dispatch' && inputs.aks_cluster_name   || secrets.AKS_CLUSTER }}

      # Prefer manual inputs if provided (and not the placeholder)
      - name: Use manual API URLs (if provided)
        id: urls
        env:
          P_IN: ${{ inputs.product_api_ip }}
          O_IN: ${{ inputs.order_api_ip }}
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.product_api_ip != '' && !contains(inputs.product_api_ip, '<ip_address>') && inputs.order_api_ip != '' && !contains(inputs.order_api_ip, '<ip_address>') }}
        run: |
          echo "product_url=${P_IN}" >> $GITHUB_OUTPUT
          echo "order_url=${O_IN}"   >> $GITHUB_OUTPUT

      # Otherwise resolve live IPs from AKS
      - name: Resolve backend IPs from AKS
        id: urls_fallback
        if: ${{ steps.urls.outputs.product_url == '' || steps.urls.outputs.order_url == '' }}
        run: |
          get_ip () { kubectl get svc "$1" -o jsonpath='{.status.loadBalancer.ingress[0].ip}'; }
          for i in {1..60}; do
            PROD=$(get_ip "${PRODUCT_SVC}") || true
            ORD=$(get_ip  "${ORDER_SVC}")  || true
            if [ -n "$PROD" ] && [ -n "$ORD" ]; then break; fi
            sleep 5
          done
          [ -n "$PROD" ] || { echo "::error::Product IP not found"; exit 1; }
          [ -n "$ORD" ]  || { echo "::error::Order IP not found"; exit 1; }
          echo "product_url=http://${PROD}:${PRODUCT_PORT}" >> $GITHUB_OUTPUT
          echo "order_url=http://${ORD}:${ORDER_PORT}"     >> $GITHUB_OUTPUT

      - name: Finalize URLs
        run: |
          P="${{ steps.urls.outputs.product_url }}"
          O="${{ steps.urls.outputs.order_url }}"
          [ -z "$P" ] && P="${{ steps.urls_fallback.outputs.product_url }}"
          [ -z "$O" ] && O="${{ steps.urls_fallback.outputs.order_url }}"
          echo "::notice:: PRODUCT_URL=$P"
          echo "::notice:: ORDER_URL=$O"
          echo "PRODUCT_URL=$P" >> $GITHUB_ENV
          echo "ORDER_URL=$O"   >> $GITHUB_ENV

      - name: Inject Backend IPs into Frontend main.js
        run: |
          sed -i "s|_PRODUCT_API_URL_|${PRODUCT_URL}|g" week08/frontend/main.js || sed -i "s|_PRODUCT_API_URL_|${PRODUCT_URL}|g" frontend/main.js
          sed -i "s|_ORDER_API_URL_|${ORDER_URL}|g"     week08/frontend/main.js || sed -i "s|_ORDER_API_URL_|${ORDER_URL}|g"     frontend/main.js
          echo "--- main.js (first 60 lines) ---"
          sed -n '1,60p' week08/frontend/main.js 2>/dev/null || sed -n '1,60p' frontend/main.js

      # robust ACR login (works if you store name or login-server in the secret)
      - name: Login to Azure Container Registry
        env:
          ACR: ${{ secrets.AZURE_CONTAINER_REGISTRY }}
        run: |
          NAME="$ACR"
          NAME="${NAME##https://}"
          NAME="${NAME%%/*}"
          NAME="${NAME%%.azurecr.io}"
          az acr login --name "$NAME"

      # >>> DO NOT CHANGE THESE LINES (as requested) <<<
      - name: Build and Push Frontend Image
        run: |
          docker build -t ${{ secrets.AZURE_CONTAINER_REGISTRY }}/frontend:latest ./frontend/
          docker push ${{ secrets.AZURE_CONTAINER_REGISTRY }}/frontend:latest

      - name: Deploy Frontend to AKS
        run: |
          echo "Deploying frontend (latest) to AKS"
          cd k8s/
          kubectl apply -f frontend.yaml
